import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
    enums: {
        // all places on the 2d map grid are either Void or Place:
        // 0x00 | 0x01
        // Voids have no Objects 
        // Places have Objects, of which Door is one.
        // Objects have Actions, eg Doors can Open or not.
        // Actions generate NESS or Bool 
        // ie. "Lock Door":
        // the Room/Place with Door with Lock -> Lock-NESS -> Place(Door(Lock(NESS(1))))
        // NB This doesn't equate to Open-NESS, a door could be LockY AND OpenY
        //
        // NB Something else abour Doors, when they are in a room they are a Door,
        // an ObjectType, when they are in a map they are a Portal. It allows us to
        // map a map, and it allows us to link a Places Door to the portal that it
        // links to. Portals connect non void places on the map.
        //
        // For now fuck it...
        //
        // we will use the keys for left shifting values
        // in a 32 bit var so we have maskable state from the
        // map data 
        TypeKeys: [
            "None", "BiomeTypes", "TerrainTypes", 
            "RoomType", "ActionType",
        ],
        BiomeType: [
            "None","Tundra", "Arctic", "Temporate", 
            "Alpine", "Jungle", "Faery"
        ],
        TerrainType: [
            "None", "Path", "Forest", "Plains", 
            "Mud", "DirtPath", "Portal"
        ],
        RoomType: [
            "None", "WoodCabin", "Store", 
            "Cavern", "StoneCabin", "Fort"
        ],
        ActionType: [
            "None", "North", "East", "South", "West", 
            "Go", "Move", "Loot", "Describe", "Take", 
            "Kick", "Lock", "Unlock", "Open"
        ],
        ObjectType: ["None", "Door", "Ball", "Key", "Window", "Knife", "Bottle"],
        MaterialType: ["None", "Wood", "Stone", "Iron", "Shit", "IKEA", "Flesh"],
        // might be useful as sort of composition for descriptions might be dumnn
        TexDefType: ["None", "Door", "WoodCabin", "DirtPath"],
        CommandError: ["LEN", "NOP"],
    },
    tables: {
        // all rooms take a description and a set of Objects that themselves
        // have descriptions and Actions.
        // We handle descriptions like everything else, its a ref to a 
        // row in a Table.
        GameMap: {
            keySchema: {},
            valueSchema: {
                width: "uint32",
                height: "uint32",
                bigOlePlace: "uint32[]",
            },
        },       
        RoomStore: {
            keySchema: {
                roomId: "uint32",
            },
            valueSchema: {
                roomType: "RoomType",
                textDefId: "uint32",
                objectIds: "uint32[]",
            },
        },
        // Actions have a NESSy property
        // like are they doable, do'y
        // eg a Winow can have an Open ActionType
        // so that wout=ld make it NESSy OpenY
        // this isn't the same as it being Open
        // it's wether it can be opened, Openy
        // this has implications and the immediate one 
        // the springs to mind is wghere is this set?
        ActionStore: {
            keySchema: {
                actionId: "uint32",
            },
            valueSchema: {
                actionType: "ActionType",
                texDefId: "uint32",
                nESSy: "bool",
                direction: "uint8",
            },
        },
        ObjectStore: {
            keySchema: {
                objectId: "uint32",
            },
            valueSchema: {
                objectType: "ObjectType",
                materialType: "MaterialType",
                texDefId: "uint32",
                objectActions: "uint32[]",
            },
        },
        // we are going to store a hash over the actual description
        // string/s here (keccak256) that will then be used as the key for the compressed
        // data on the client which de-compresses it from some form of hash map or what have you
        // it should be generated by build tools. It isn't.
        TextDef: {
            keySchema: {
                texDefId: "uint32",
                texDefType: "uint8",
            },
            valueSchema: "bytes",
        },
        CurrentRoomId: {
            keySchema: {},
            valueSchema: "uint32",
        },
        Output: {
            keySchema: {},
            valueSchema: "string",
        },
    },
});
